ðŸš€Â COMPLETE REACT NATIVE MIGRATION BLUEPRINT FOR KINDRA
âš¡ INSTANT SETUP GUIDE - COPY-PASTE READY
ðŸ“ STEP 1: CORE FOUNDATION (2 hours)
1.1 Initialize React Native App
npx create-expo-app@latest KindraApp --template typescript
cd KindraApp
npx expo install react-native-web@~0.19.6

1.2 Install Required Dependencies
# Core navigation and state management
npm install @react-navigation/native @react-navigation/native-stack @react-navigation/bottom-tabs
npm install react-native-screens react-native-safe-area-context
npx expo install expo-secure-store expo-async-storage

# Data layer (identical to web app)
npm install @tanstack/react-query drizzle-orm @neondatabase/serverless
npm install zod react-hook-form @hookform/resolvers

# UI and styling
npm install nativewind react-native-svg lucide-react-native
npm install clsx tailwind-merge class-variance-authority

# Date handling (same as web)
npm install date-fns

# Authentication and media
npx expo install expo-auth-session expo-crypto expo-image-picker

1.3 Configure NativeWind
// tailwind.config.js
module.exports = {
content: ["./App.{js,jsx,ts,tsx}", "./src/**/*.{js,jsx,ts,tsx}"],
theme: {
extend: {
colors: {
primary: '#8B5CF6',
secondary: '#EC4899',
accent: '#10B981',
background: '#F8FAFC',
surface: '#FFFFFF',
border: '#E2E8F0',
text: '#1E293B',
'text-secondary': '#64748B',
destructive: '#EF4444'
}
}
},
plugins: [],
}


ðŸ“‹ STEP 2: DIRECT COPY FILES (30 minutes)
2.1 Create folder structure and copy these files EXACTLY:
// src/shared/schema.ts (COPY ENTIRE FILE - 500+ lines)
import { pgTable, text, serial, integer, boolean, timestamp, json, varchar, index } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// Session storage table for authentication
export const sessions = pgTable(
"sessions",
{
sid: varchar("sid").primaryKey(),
sess: json("sess").notNull(),
expire: timestamp("expire").notNull(),
},
(table) => [index("IDX_session_expire").on(table.expire)],
);

// Users with Google auth support
export const users = pgTable("users", {
id: varchar("id").primaryKey().notNull(),
email: varchar("email").unique(),
firstName: varchar("first_name"),
lastName: varchar("last_name"),
profileImageUrl: varchar("profile_image_url"),
username: text("username").unique(),
password: text("password"),
displayName: text("display_name"),
birthday: timestamp("birthday"),
zodiacSign: text("zodiac_sign"),
loveLanguage: text("love_language"),
relationshipGoals: text("relationship_goals"),
currentFocus: text("current_focus"),
relationshipStyle: text("relationship_style"),
personalNotes: text("personal_notes"),
stripeCustomerId: text("stripe_customer_id"),
stripeSubscriptionId: text("stripe_subscription_id"),
subscriptionStatus: text("subscription_status").default("free"),
subscriptionPlan: text("subscription_plan"),
subscriptionStartDate: timestamp("subscription_start_date"),
subscriptionEndDate: timestamp("subscription_end_date"),
trialEndDate: timestamp("trial_end_date"),
points: integer("points").default(0),
monthlyAiInsights: integer("monthly_ai_insights").default(0),
monthlyAiCoaching: integer("monthly_ai_coaching").default(0),
lastUsageReset: timestamp("last_usage_reset").defaultNow(),
createdAt: timestamp("created_at").defaultNow(),
updatedAt: timestamp("updated_at").defaultNow(),
});

// Subscription plans configuration
export const subscriptionPlans = {
free: {
name: "Free",
price: 0,
interval: null,
features: {
connections: 1,
aiInsightsPerMonth: 3,
aiCoachingPerMonth: 3,
advancedAnalytics: false,
cycleTracking: "basic",
dataExport: false,
prioritySupport: false,
adFree: false
}
},
weekly: {
name: "Premium Weekly",
price: 1.99,
interval: "week",
features: {
connections: "unlimited",
aiInsightsPerMonth: "unlimited",
aiCoachingPerMonth: "unlimited",
advancedAnalytics: true,
cycleTracking: "advanced",
dataExport: true,
prioritySupport: true,
adFree: true
}
},
monthly: {
name: "Premium Monthly",
price: 4.99,
interval: "month",
features: {
connections: "unlimited",
aiInsightsPerMonth: "unlimited",
aiCoachingPerMonth: "unlimited",
advancedAnalytics: true,
cycleTracking: "advanced",
dataExport: true,
prioritySupport: true,
adFree: true
}
},
annual: {
name: "Premium Annual",
price: 39.99,
interval: "year",
features: {
connections: "unlimited",
aiInsightsPerMonth: "unlimited",
aiCoachingPerMonth: "unlimited",
advancedAnalytics: true,
cycleTracking: "advanced",
dataExport: true,
prioritySupport: true,
adFree: true
}
}
} as const;

// Relationship stages enum
export const relationshipStages = [
"Potential",
"Talking",
"Situationship",
"It's Complicated",
"Dating",
"Spouse",
"Ex"
] as const;

// Connections table
export const connections = pgTable("connections", {
id: serial("id").primaryKey(),
userId: varchar("user_id").notNull().references(() => users.id),
name: text("name").notNull(),
profileImage: text("profile_image"),
birthday: timestamp("birthday"),
zodiacSign: text("zodiac_sign"),
loveLanguage: text("love_language"),
relationshipStage: text("relationship_stage").default("Potential"),
metAt: text("met_at"),
connectionDate: timestamp("connection_date"),
notes: text("notes"),
tags: text("tags").array(),
points: integer("points").default(0),
isArchived: boolean("is_archived").default(false),
createdAt: timestamp("created_at").defaultNow(),
updatedAt: timestamp("updated_at").defaultNow(),
});

// Moments table
export const moments = pgTable("moments", {
id: serial("id").primaryKey(),
userId: varchar("user_id").notNull().references(() => users.id),
connectionId: integer("connection_id").references(() => connections.id),
title: text("title").notNull(),
description: text("description"),
emoji: text("emoji").notNull(),
date: timestamp("date").notNull(),
tags: text("tags").array(),
mood: text("mood"),
location: text("location"),
isPrivate: boolean("is_private").default(false),
createdAt: timestamp("created_at").defaultNow(),
updatedAt: timestamp("updated_at").defaultNow(),
});

// Menstrual cycles table
export const menstrualCycles = pgTable("menstrual_cycles", {
id: serial("id").primaryKey(),
userId: varchar("user_id").notNull().references(() => users.id),
connectionId: integer("connection_id").references(() => connections.id),
periodStartDate: timestamp("period_start_date").notNull(),
periodEndDate: timestamp("period_end_date"),
cycleEndDate: timestamp("cycle_end_date"),
cycleLength: integer("cycle_length").default(28),
mood: text("mood"),
symptoms: text("symptoms").array(),
notes: text("notes"),
ovulationDay: integer("ovulation_day"),
createdAt: timestamp("created_at").defaultNow(),
updatedAt: timestamp("updated_at").defaultNow(),
});

// Export types
export type User = typeof users.$inferSelect;
export type UpsertUser = typeof users.$inferInsert;
export type Connection = typeof connections.$inferSelect;
export type InsertConnection = typeof connections.$inferInsert;
export type Moment = typeof moments.$inferSelect;
export type InsertMoment = typeof moments.$inferInsert;
export type MenstrualCycle = typeof menstrualCycles.$inferSelect;
export type InsertMenstrualCycle = typeof menstrualCycles.$inferInsert;

// Create schemas
export const userSchema = createInsertSchema(users);
export const connectionSchema = createInsertSchema(connections);
export const momentSchema = createInsertSchema(moments);
export const menstrualCycleSchema = createInsertSchema(menstrualCycles);

2.2 API Client (React Native Adapted)
// src/lib/queryClient.ts
import { QueryClient, QueryFunction } from "@tanstack/react-query";
import * as SecureStore from 'expo-secure-store';

const API_BASE_URL = 'https://your-api-domain.com'; // Replace with your API URL

async function throwIfResNotOk(res: Response) {
if (!res.ok) {
let errorMessage = res.statusText;
try {
const responseText = await res.text();
try {
const errorData = JSON.parse(responseText);
if (errorData.message) {
errorMessage = errorData.message;
} else if (errorData.error) {
errorMessage = errorData.error;
} else {
errorMessage = responseText;
}
} catch (jsonError) {
errorMessage = responseText || res.statusText;
}
} catch (e) {
errorMessage = res.statusText;
}
throw new Error(errorMessage);
}
}

export async function apiRequest(
url: string,
method: string,
data?: unknown | undefined,
): Promise<Response> {
// Get auth token from secure storage
const token = await SecureStore.getItemAsync('authToken');

const headers: HeadersInit = {
...(data ? { "Content-Type": "application/json" } : {}),
...(token ? { "Authorization": `Bearer ${token}` } : {}),
};

const res = await fetch(`${API_BASE_URL}${url}`, {
method,
headers,
body: data ? JSON.stringify(data) : undefined,
});

await throwIfResNotOk(res);
return res;
}

export const getQueryFn: <T>(options: {
on401: "returnNull" | "throw";
}) => QueryFunction<T> =
({ on401: unauthorizedBehavior }) =>
async ({ queryKey }) => {
const token = await SecureStore.getItemAsync('authToken');

const res = await fetch(`${API_BASE_URL}${queryKey[0]}`, {
headers: {
...(token ? { "Authorization": `Bearer ${token}` } : {}),
},
});

if ((res.status === 401 || res.status === 404) && unauthorizedBehavior === "returnNull") {
return null;
}

if (unauthorizedBehavior === "returnNull" && res.status === 401) {
return null;
}

await throwIfResNotOk(res);

const contentType = res.headers.get('content-type');
if (!contentType || !contentType.includes('application/json')) {
const text = await res.text();
if (!text.trim()) {
return null;
}
throw new Error(`Expected JSON response but got: ${contentType}`);
}

const text = await res.text();
if (!text.trim()) {
return null;
}

return JSON.parse(text);
};

export const queryClient = new QueryClient({
defaultOptions: {
queries: {
queryFn: getQueryFn({ on401: "throw" }),
refetchInterval: false,
refetchOnWindowFocus: false,
refetchOnMount: false,
refetchOnReconnect: false,
staleTime: 5 * 60 * 1000,
gcTime: 5 * 60 * 1000,
retry: 0,
retryDelay: 0,
},
mutations: {
retry: false,
gcTime: 0,
},
},
});

2.3 Utility Functions (ZERO CHANGES)
// src/lib/utils.ts
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
return twMerge(clsx(inputs))
}

2.4 Complete Business Logic (COPY ENTIRE FILES)
// src/lib/relationship-analytics.ts (COPY ENTIRE 600+ line file)
// src/lib/cycle-utils.ts (COPY ENTIRE 300+ line file)
// Both files work identically in React Native - zero changes needed


ðŸ“± STEP 3: CONTEXT PROVIDERS (React Native Adapted)
3.1 Authentication Context
// src/contexts/AuthContext.tsx
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { useQuery } from '@tanstack/react-query';
import * as SecureStore from 'expo-secure-store';
import { router } from 'expo-router';

interface User {
id: string;
email: string;
firstName?: string;
lastName?: string;
profileImageUrl?: string;
displayName?: string;
zodiacSign?: string;
loveLanguage?: string;
createdAt: Date;
updatedAt: Date;
}

interface AuthContextType {
user: User | null;
loading: boolean;
isAuthenticated: boolean;
logout: () => void;
refreshUser: () => void;
login: (token: string) => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: ReactNode }) {
const [user, setUser] = useState<User | null>(null);
const [token, setToken] = useState<string | null>(null);

// Load token on app start
useEffect(() => {
const loadToken = async () => {
const storedToken = await SecureStore.getItemAsync('authToken');
if (storedToken) {
setToken(storedToken);
}
};
loadToken();
}, []);

const { data: currentUser, isLoading, error, refetch } = useQuery({
queryKey: ['/api/me'],
enabled: !!token,
retry: false,
staleTime: 0,
queryFn: async () => {
const response = await fetch('/api/me', {
headers: {
'Authorization': `Bearer ${token}`,
},
});
if (!response.ok) {
throw new Error(`${response.status}: ${response.statusText}`);
}
return response.json();
}
});

useEffect(() => {
if (currentUser && typeof currentUser === 'object' && currentUser.id) {
setUser(currentUser);
} else if (error) {
setUser(null);
} else if (!isLoading) {
setUser(null);
}
}, [currentUser, error, isLoading]);

const login = async (authToken: string) => {
await SecureStore.setItemAsync('authToken', authToken);
setToken(authToken);
refetch();
};

const logout = async () => {
await SecureStore.deleteItemAsync('authToken');
setToken(null);
setUser(null);
router.replace('/login');
};

const refreshUser = () => {
refetch();
};

const value: AuthContextType = {
user: currentUser || null,
loading: isLoading,
isAuthenticated: !!(currentUser && currentUser.id),
logout,
refreshUser,
login,
};

return (
<AuthContext.Provider value={value}>
{children}
</AuthContext.Provider>
);
}

export function useAuth() {
const context = useContext(AuthContext);
if (context === undefined) {
throw new Error('useAuth must be used within an AuthProvider');
}
return context;
}

3.2 Theme Context (React Native Adapted)
// src/contexts/ThemeContext.tsx
import React, { createContext, useContext, useEffect, useState } from "react";
import AsyncStorage from '@react-native-async-storage/async-storage';

type Theme = "light" | "dark" | "minimalist";

interface ThemeContextType {
theme: Theme;
setTheme: (theme: Theme) => void;
actualTheme: "light" | "dark";
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export function ThemeProvider({ children }: { children: React.ReactNode }) {
const [theme, setTheme] = useState<Theme>("light");
const [actualTheme, setActualTheme] = useState<"light" | "dark">("light");

// Load theme on app start
useEffect(() => {
const loadTheme = async () => {
try {
const stored = await AsyncStorage.getItem("theme") as Theme;
if (stored) {
setTheme(stored);
}
} catch (error) {
console.error('Failed to load theme:', error);
}
};
loadTheme();
}, []);

// Save theme changes
useEffect(() => {
const saveTheme = async () => {
try {
await AsyncStorage.setItem("theme", theme);
} catch (error) {
console.error('Failed to save theme:', error);
}
};
saveTheme();

let effectiveTheme: "light" | "dark";
if (theme === "minimalist") {
effectiveTheme = "light";
} else {
effectiveTheme = theme as "light" | "dark";
}
setActualTheme(effectiveTheme);
}, [theme]);

const value: ThemeContextType = {
theme,
setTheme,
actualTheme,
};

return (
<ThemeContext.Provider value={value}>
{children}
</ThemeContext.Provider>
);
}

export function useTheme() {
const context = useContext(ThemeContext);
if (!context) {
throw new Error("useTheme must be used within a ThemeProvider");
}
return context;
}

3.3 Modal Context (React Native Adapted)
// src/contexts/ModalContext.tsx
import { createContext, useContext, useState } from "react";
import { Connection, Moment } from "../shared/schema";

type ModalContextType = {
momentModalOpen: boolean;
planModalOpen: boolean;
selectedConnectionId: number | null;
selectedConnection: Connection | null;
mainFocusConnection: Connection | null;
activityType: 'moment' | 'conflict' | 'intimacy' | 'plan';
editingMoment: Moment | null;
selectedDate: Date | null;
navigationConnectionId: number | null;
openMomentModal: (activityType?: 'moment' | 'conflict' | 'intimacy' | 'plan', moment?: Moment, date?: Date) => void;
closeMomentModal: () => void;
openPlanModal: (connection?: Connection, date?: Date) => void;
closePlanModal: () => void;
setSelectedConnection: (connectionId: number | null, connection?: Connection | null) => void;
setMainFocusConnection: (connection: Connection | null) => void;
setNavigationConnectionId: (connectionId: number | null) => void;
onConnectionChanged?: (connectionId: number | null) => void;
registerConnectionChangeListener: (callback: (connectionId: number | null) => void) => void;
};

const ModalContext = createContext<ModalContextType>({
momentModalOpen: false,
planModalOpen: false,
selectedConnectionId: null,
selectedConnection: null,
mainFocusConnection: null,
activityType: 'moment',
editingMoment: null,
selectedDate: null,
navigationConnectionId: null,
openMomentModal: () => {},
closeMomentModal: () => {},
openPlanModal: () => {},
closePlanModal: () => {},
setSelectedConnection: () => {},
setMainFocusConnection: () => {},
setNavigationConnectionId: () => {},
onConnectionChanged: undefined,
registerConnectionChangeListener: () => {},
});

export const useModal = () => useContext(ModalContext);

export const ModalProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
const [momentModalOpen, setMomentModalOpen] = useState(false);
const [planModalOpen, setPlanModalOpen] = useState(false);
const [selectedConnectionId, setSelectedConnectionId] = useState<number | null>(null);
const [selectedConnection, setSelectedConnectionObject] = useState<Connection | null>(null);
const [mainFocusConnection, setMainFocusConnectionObject] = useState<Connection | null>(null);
const [activityType, setActivityType] = useState<'moment' | 'conflict' | 'intimacy' | 'plan'>('moment');
const [editingMoment, setEditingMoment] = useState<Moment | null>(null);
const [selectedDate, setSelectedDate] = useState<Date | null>(null);
const [navigationConnectionId, setNavigationConnectionId] = useState<number | null>(null);
const [connectionChangeListener, setConnectionChangeListener] = useState<((connectionId: number | null) => void) | undefined>(undefined);

const openMomentModal = (activityType: 'moment' | 'conflict' | 'intimacy' | 'plan' = 'moment', moment?: Moment, date?: Date) => {
if (activityType === 'plan') {
setEditingMoment(moment || null);
setSelectedDate(date || null);
setPlanModalOpen(true);
} else {
setActivityType(activityType);
setEditingMoment(moment || null);
setSelectedDate(date || null);
setMomentModalOpen(true);
}
};

const closeMomentModal = () => {
setMomentModalOpen(false);
setSelectedDate(null);
};

const openPlanModal = (connection?: Connection, date?: Date) => {
if (connection) {
setSelectedConnectionObject(connection);
setSelectedConnectionId(connection.id);
}
if (date) {
setSelectedDate(date);
}
setPlanModalOpen(true);
};

const closePlanModal = () => {
setPlanModalOpen(false);
};

const setSelectedConnection = (connectionId: number | null, connection?: Connection | null) => {
setSelectedConnectionId(connectionId);
setSelectedConnectionObject(connection || null);

if (connectionChangeListener) {
connectionChangeListener(connectionId);
}
};

const registerConnectionChangeListener = (callback: (connectionId: number | null) => void) => {
setConnectionChangeListener(() => callback);
};

return (
<ModalContext.Provider
value={{
momentModalOpen,
planModalOpen,
selectedConnectionId,
selectedConnection,
mainFocusConnection,
activityType,
editingMoment,
selectedDate,
navigationConnectionId,
openMomentModal,
closeMomentModal,
openPlanModal,
closePlanModal,
setSelectedConnection,
setMainFocusConnection: setMainFocusConnectionObject,
setNavigationConnectionId,
onConnectionChanged: connectionChangeListener,
registerConnectionChangeListener,
}}
>
{children}
</ModalContext.Provider>
);
};


ðŸ“± STEP 4: NAVIGATION SETUP
4.1 Main Navigation Structure
// src/navigation/TabNavigator.tsx
import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { Brain, Users, Heart, Calendar, LineChart } from 'lucide-react-native';
import { View, Text } from 'react-native';

// Import your screens
import AIScreen from '../screens/AIScreen';
import ConnectionsScreen from '../screens/ConnectionsScreen';
import ActivitiesScreen from '../screens/ActivitiesScreen';
import CalendarScreen from '../screens/CalendarScreen';
import InsightsScreen from '../screens/InsightsScreen';

const Tab = createBottomTabNavigator();

export default function TabNavigator() {
return (
<Tab.Navigator
screenOptions={({ route }) => ({
tabBarIcon: ({ focused, color, size }) => {
let IconComponent;

switch (route.name) {
case 'AI':
IconComponent = Brain;
break;
case 'Connections':
IconComponent = Users;
break;
case 'Activities':
IconComponent = Heart;
break;
case 'Calendar':
IconComponent = Calendar;
break;
case 'Insights':
IconComponent = LineChart;
break;
default:
IconComponent = Brain;
}

return <IconComponent size={size} color={color} />;
},
tabBarActiveTintColor: '#8B5CF6',
tabBarInactiveTintColor: '#64748B',
tabBarStyle: {
backgroundColor: '#FFFFFF',
borderTopWidth: 1,
borderTopColor: '#E2E8F0',
height: 60,
paddingBottom: 8,
paddingTop: 8,
},
tabBarLabelStyle: {
fontSize: 10,
fontWeight: '500',
},
headerShown: false,
})}
>
<Tab.Screen name="AI" component={AIScreen} />
<Tab.Screen name="Connections" component={ConnectionsScreen} />
<Tab.Screen name="Activities" component={ActivitiesScreen} />
<Tab.Screen name="Calendar" component={CalendarScreen} />
<Tab.Screen name="Insights" component={InsightsScreen} />
</Tab.Navigator>
);
}

4.2 App Navigation
// src/navigation/AppNavigator.tsx
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { useAuth } from '../contexts/AuthContext';
import TabNavigator from './TabNavigator';
import LoginScreen from '../screens/LoginScreen';
import OnboardingScreen from '../screens/OnboardingScreen';

const Stack = createNativeStackNavigator();

export default function AppNavigator() {
const { isAuthenticated, user, loading } = useAuth();

if (loading) {
return <LoadingScreen />;
}

const needsOnboarding = user && !user.displayName;

return (
<NavigationContainer>
<Stack.Navigator screenOptions={{ headerShown: false }}>
{!isAuthenticated ? (
<Stack.Screen name="Login" component={LoginScreen} />
) : needsOnboarding ? (
<Stack.Screen name="Onboarding" component={OnboardingScreen} />
) : (
<Stack.Screen name="Main" component={TabNavigator} />
)}
</Stack.Navigator>
</NavigationContainer>
);
}


ðŸ“± STEP 5: MAIN APP COMPONENT
// App.tsx
import React from 'react';
import { QueryClientProvider } from '@tanstack/react-query';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { queryClient } from './src/lib/queryClient';
import { AuthProvider } from './src/contexts/AuthContext';
import { ThemeProvider } from './src/contexts/ThemeContext';
import { ModalProvider } from './src/contexts/ModalContext';
import AppNavigator from './src/navigation/AppNavigator';

export default function App() {
return (
<GestureHandlerRootView style={{ flex: 1 }}>
<SafeAreaProvider>
<QueryClientProvider client={queryClient}>
<AuthProvider>
<ThemeProvider>
<ModalProvider>
<AppNavigator />
</ModalProvider>
</ThemeProvider>
</AuthProvider>
</QueryClientProvider>
</SafeAreaProvider>
</GestureHandlerRootView>
);
}


ðŸ“± STEP 6: SAMPLE SCREEN IMPLEMENTATIONS
6.1 AI Screen Example
// src/screens/AIScreen.tsx
import React, { useState } from 'react';
import { View, Text, TextInput, TouchableOpacity, ScrollView, KeyboardAvoidingView, Platform } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useQuery, useMutation } from '@tanstack/react-query';
import { useAuth } from '../contexts/AuthContext';
import { apiRequest } from '../lib/queryClient';

export default function AIScreen() {
const [message, setMessage] = useState('');
const [conversation, setConversation] = useState<Array<{user: string, assistant: string}>>([]);
const { user, isAuthenticated } = useAuth();

const sendMessageMutation = useMutation({
mutationFn: async (message: string) => {
const response = await apiRequest('/api/ai/chat', 'POST', { message });
return response.json();
},
onSuccess: (data) => {
setConversation(prev => [...prev, { user: message, assistant: data.response }]);
setMessage('');
},
});

const handleSendMessage = () => {
if (message.trim()) {
sendMessageMutation.mutate(message);
}
};

if (!isAuthenticated) {
return (
<SafeAreaView className="flex-1 justify-center items-center bg-background">
<Text className="text-xl text-text">Please log in to access AI coach</Text>
</SafeAreaView>
);
}

return (
<SafeAreaView className="flex-1 bg-background">
<KeyboardAvoidingView
behavior={Platform.OS ===
